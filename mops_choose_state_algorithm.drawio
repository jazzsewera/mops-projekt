<mxfile host="65bd71144e" modified="2020-12-01T10:16:01.465Z" agent="5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Code/1.51.1 Chrome/83.0.4103.122 Electron/9.3.3 Safari/537.36" etag="EdSQAWcTZRG7sJu92vn8" version="13.6.5">
    <diagram id="lDJ51UvGYAP5vDOC0IsP" name="Page-1">
        <mxGraphModel dx="990" dy="575" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="827" pageHeight="1169" math="0" shadow="0">
            <root>
                <mxCell id="0"/>
                <mxCell id="1" parent="0"/>
                <mxCell id="5" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=0.5;exitY=1;exitDx=0;exitDy=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;" parent="1" source="2" target="3" edge="1">
                    <mxGeometry relative="1" as="geometry"/>
                </mxCell>
                <mxCell id="2" value="default" style="rounded=1;whiteSpace=wrap;html=1;arcSize=50;" parent="1" vertex="1">
                    <mxGeometry x="330" y="70" width="120" height="60" as="geometry"/>
                </mxCell>
                <mxCell id="8" value="ON" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0.5;entryY=0;entryDx=0;entryDy=0;" parent="1" source="3" edge="1">
                    <mxGeometry x="0.25" relative="1" as="geometry">
                        <mxPoint x="275" y="330" as="targetPoint"/>
                        <Array as="points">
                            <mxPoint x="275" y="230"/>
                        </Array>
                        <mxPoint as="offset"/>
                    </mxGeometry>
                </mxCell>
                <mxCell id="9" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=1;exitY=0.5;exitDx=0;exitDy=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;" parent="1" source="3" edge="1">
                    <mxGeometry relative="1" as="geometry">
                        <mxPoint x="505" y="330" as="targetPoint"/>
                    </mxGeometry>
                </mxCell>
                <mxCell id="10" value="OFF" style="edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];" parent="9" vertex="1" connectable="0">
                    <mxGeometry x="-0.25" y="-33" relative="1" as="geometry">
                        <mxPoint x="33" y="40" as="offset"/>
                    </mxGeometry>
                </mxCell>
                <mxCell id="3" value="choose_state()" style="rhombus;whiteSpace=wrap;html=1;" parent="1" vertex="1">
                    <mxGeometry x="335" y="190" width="110" height="80" as="geometry"/>
                </mxCell>
                <mxCell id="12" value="default" style="rounded=1;whiteSpace=wrap;html=1;arcSize=50;" parent="1" vertex="1">
                    <mxGeometry x="325" y="550" width="120" height="60" as="geometry"/>
                </mxCell>
                <mxCell id="17" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;" parent="1" source="15" target="12" edge="1">
                    <mxGeometry relative="1" as="geometry"/>
                </mxCell>
                <mxCell id="15" value="send()" style="shape=parallelogram;perimeter=parallelogramPerimeter;whiteSpace=wrap;html=1;fixedSize=1;" parent="1" vertex="1">
                    <mxGeometry x="215" y="330" width="120" height="60" as="geometry"/>
                </mxCell>
                <mxCell id="18" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0.5;entryY=0;entryDx=0;entryDy=0;" parent="1" source="16" target="12" edge="1">
                    <mxGeometry relative="1" as="geometry"/>
                </mxCell>
                <mxCell id="16" value="idle()" style="shape=parallelogram;perimeter=parallelogramPerimeter;whiteSpace=wrap;html=1;fixedSize=1;" parent="1" vertex="1">
                    <mxGeometry x="445" y="330" width="120" height="60" as="geometry"/>
                </mxCell>
                <mxCell id="19" value="Title: Model symulacji — raport częściowy — Projekt MOPS&#13;&#10;Author: Błażej Sewera, Mateusz Winnicki, Wojciech Kowalski&#13;&#10;Date: 1 grudnia 2020&#13;&#10;Language: pl&#13;&#10;Geometry: margin=2.2cm&#13;&#10;&#13;&#10;# Projekt MOPS&#13;&#10;&#13;&#10;## Cele projektu&#13;&#10;Celem projektu jest zasymulowanie węzła lub systemu dwóch węzłów sieciowych,&#13;&#10;obsługujących $n$ źródeł ruchu typu ON-OFF, zdolnych generować pakiety o&#13;&#10;stałej długości $L$ w stanie ON.&#13;&#10;&#13;&#10;Każdy węzeł sieciowy modelujemy jako nieskończoną kolejkę FIFO, każdy ma&#13;&#10;podłączoną dowolną liczbę źródeł ruchu.&#13;&#10;&#13;&#10;Liczba pakietów w stanie ON jest opisywana rozkładem geometrycznym o funkcji&#13;&#10;rozkładu prawdopodobieństwa:&#13;&#10;$$&#13;&#10;n_{ON} = (1-p_{ON})^{k-1} p_{ON}&#13;&#10;$$&#13;&#10;$$&#13;&#10;n_{ONavg} = \frac{1}{p_{ON}}&#13;&#10;$$&#13;&#10;gdzie $n_{ON}$ to liczba pakietów przesłana w jednej iteracji stanu ON.&#13;&#10;Odstęp między pakietami (czas interwału) jest stały i wynosi $t_{int}$.&#13;&#10;&#13;&#10;Wtedy średni czas trwania stanu ON:&#13;&#10;$$&#13;&#10;t_{ONavg} = \frac{t_{int}}{p_{ON}} + t_{prog}&#13;&#10;$$&#13;&#10;gdzie $t_{prog}$ to dodatkowy czas wprowadzany przez ograniczenia narzędzi&#13;&#10;programistycznych, implementacji i sprzętu, który dla uproszczenia pominiemy.&#13;&#10;&#13;&#10;Średnia liczba bitów wysłanych przez źródło podczas jednego stanu ON wynosi:&#13;&#10;$$&#13;&#10;n_{b\,avg} = \frac{L}{p_{ON}}&#13;&#10;$$&#13;&#10;&#13;&#10;Długość stanu OFF opisana jest rozkładem wykładniczym.&#13;&#10;$$&#13;&#10;t_{OFF} = \lambda e^{-\lambda t}&#13;&#10;$$&#13;&#10;$$&#13;&#10;t_{OFFavg} = \frac{1}{\lambda}&#13;&#10;$$&#13;&#10;&#13;&#10;Dla uproszczenia, można posłużyć się podobnym rozkładem geometrycznym dla&#13;&#10;długości stanu OFF, tylko w odróżnieniu od stanu ON, nie symulujemy wysyłania&#13;&#10;pakietów, a jedynie uwzględniamy interwał pomiędzy kolejnymi iteracjami tego&#13;&#10;stanu, czyli de facto bezczynnością.&#13;&#10;$$&#13;&#10;t_{OFFavg} = \frac{1}{p_{OFF}} \cdot t_{int}&#13;&#10;$$&#13;&#10;&#13;&#10;Z racji że stany ON i OFF następują naprzemiennie, średni czas trwania tych dwóch stanów:&#13;&#10;$$&#13;&#10;t_{ON\,OFF\,avg} = \frac{t_{int}}{p_{ON}} + \frac{t_{int}}{p_{OFF}} = \frac{t_{int} \cdot (p_{ON} + p_{OFF})}{p_{ON} \cdot p_{OFF}}&#13;&#10;$$&#13;&#10;&#13;&#10;Na podstawie powyższych danych można obliczyć średnią przepływność generowaną przez jedno źródło:&#13;&#10;$$&#13;&#10;BR_{avg} = \frac{n_{b}}{t_{ON\,OFF\,avg}} = \frac{L p_{ON} p_{OFF}}{t_{int} p_{ON} (p_{ON} + p_{OFF})}&#13;&#10;$$&#13;&#10;&#13;&#10;Badane metryki pomiarowe:&#13;&#10;&#13;&#10;- średnia liczba pakietów w kolejce $l_{queue}$&#13;&#10;- średni czas oczekiwania w kolejce $t_{wait}$&#13;&#10;- średnie opóźnienie przekazu pakietu, definiowane jako średnia suma czasu&#13;&#10;  oczekiwania w kolejce oraz czasu odebrania całego pakietu przez węzeł&#13;&#10;  sieciowy. Jako że długość pakietu jest stała i wynosi L, czas odebrania&#13;&#10;  pakietu przez węzeł również będzie stały $t_{delay} = t_{wait} + T_{receive}$&#13;&#10;- średnie obciążenie serwera&#13;&#10;&#13;&#10;Przedstawiony model zaimplementujemy w języku programowania Python.&#13;&#10;&#13;&#10;## Scenariusz i algorytmy&#13;&#10;&#13;&#10;```&#13;&#10;napływ klientów -&gt; kolejka -&gt; serwer&#13;&#10;&#13;&#10;nadawca \                       / odbiorca&#13;&#10;nadawca -&gt; kolejka z serwerem &lt;-  odbiorca&#13;&#10;nadawca /                       \ odbiorca&#13;&#10;```&#13;&#10;&#13;&#10;Automat przedstawiający nadawcę ON/OFF&#13;&#10;&#13;&#10;Jeden stan będzie trwał T (np. 0.01s)&#13;&#10;&#13;&#10;```&#13;&#10;    (default)&#13;&#10;        |&#13;&#10; &lt;choose_state()&gt;&#13;&#10;    /       \&#13;&#10;  (ON)     (OFF)&#13;&#10;    |       |&#13;&#10;/send()/  /idle()/&#13;&#10;    \       /&#13;&#10;    (default)&#13;&#10;```&#13;&#10;&#13;&#10;```python&#13;&#10;import numpy as np&#13;&#10;import random&#13;&#10;&#13;&#10;T = 0.01  # stan trwa 0.01s&#13;&#10;&#13;&#10;def choose_state():&#13;&#10;    if bool(random.getrandbits(1)):&#13;&#10;        send()&#13;&#10;    else:&#13;&#10;        idle()&#13;&#10;&#13;&#10;def send():&#13;&#10;    duration = np.random.exponential(scale=1)&#13;&#10;    iterations = int(1/T * duration)&#13;&#10;    for iterations:&#13;&#10;        # send data&#13;&#10;        sleep(T)&#13;&#10;&#13;&#10;def idle():&#13;&#10;    duration = np.random.exponential(scale=1)&#13;&#10;    iterations = int(1/T * duration)&#13;&#10;    for iterations:&#13;&#10;        sleep(T)&#13;&#10;```" style="text;whiteSpace=wrap;html=1;" vertex="1" parent="1">
                    <mxGeometry x="430" y="430" width="550" height="1650" as="geometry"/>
                </mxCell>
            </root>
        </mxGraphModel>
    </diagram>
</mxfile>